t
# for some reason the last call is
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
results <- cbind(models, do.call(rbind, t))
results
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
log_vec <- eval(parse(text = condition))
plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
}
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
results <- cbind(models, do.call(rbind, t))
results
results
results <- cbind(do.call(rbind, t), models)
resuts
results
library(lobstr)
ast(parse("State == 'mp"))
ast(parse("5+5*9))
)
))
library(lobstr)
parse(5+5*9)
parse(text = "5+5*9')
""
"
parse(text = "5+5*9")
ast(parse(text = "5+5*9"))
ast(parse(text = "cor(x,y)"))
ast(cor(x,y)))
ast(cor(x,y))
eval(parse(text = "5+5"))
ast(parse(text = "5+5"))
ast(parse(text = "5+5")[1])
ast(sym ("5+5"))
ast(parse_expr(text = "5+5")[1])
ast(parse_exprs("5+5"))
ast(5+5)
ast(parse_expr("5+5"))
ast(parse_expr(parse_expr("5+5")))
ast(parse_expr("rnorm(10,1)"))
ast(rnorm(10,1))
?parse_expr
ast(parse_expr("mtcars %>% dplyr::mutate(cyl_prime = cyl / sd(cyl))"))
ast(parse_expr("rnorm(10,1)"))
a <- parse_expr("rnorm(10,1)")
library(rlang)
a <- parse_expr("rnorm(10,1)")
ast(parse_expr("rnorm(10,1)"))
ast(rlang::parse_expr("rnorm(10,1)"))
t <- rlang::parse_expr("rnorm(10,1)")
t
ast(t)
ast(!!t)
ast(!!rlang::parse_expr("rnorm(10,1)"))
ast(!!parse_expr("rnorm(10,1)"))
ast(parse_expr("rnorm(10,1)"))
library(tidyverse)
library(plm)
library(rlang)
library(broom)
data_path <- "C:/Users/dougj/Documents/Data/Education"
states <- read_csv(file.path(data_path, "ASER trends over time", "aser_trends.csv"))
dists <- read_csv(file.path(data_path, "ASER District Data", "Clean", "aser_district_5_or_6.csv"))
# Create vector of all learning outcome variables
outcomes <- str_subset(names(states), "^std.*all$")
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
for (y in outcomes) {
print(y)
# create string of formula.
rx <- paste(y, "~ state_factor + year_factor + pvt")
print("Without MP")
fit_no_mp <- plm(rx, data = states, subset = (State != "madhyapradesh"), index = "state_factor")
fit_no_mp_tidy <- tidy(fit_no_mp)
print(fit_no_mp_tidy[fit_no_mp_tidy$term == "pvt",])
print("With MP")
fit_with_mp <- plm(rx, data = states, index = "state_factor")
fit_tidy <- tidy(fit_no_mp)
print(fit_no_mp_tidy[fit_no_mp_tidy$term == "pvt",])
}
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
log_vec <- eval(parse(text = condition))
plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
}
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
results <- cbind(do.call(rbind, t), models)
t
bind_row(!!!t)
bind_rows(!!!t)
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
results <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",]) %>% bind_rows(!!!.x)
results <- bind_cols(bind_rows(!!!t), models)
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
results <- bind_cols(bind_rows(!!!t), models)
results
!!!t
?bind_rows
library(rlang)
library(lobstr)
f <- expr(mean(1:10))
f
f$na.rm <- TRUE
f
class(f)
f[1]
f[[[1]]
f[[1]]
f[[1]] <- median
f
eval(f)
ast(
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
log_vec <- eval(parse(text = condition))
plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
})
?env
?eval_tidy
?expr
f <- expr(5+5)
g <- parse_expr("5+5")
f
g
ast(!!f)
ast(!!g)
expr(read.csv("foo.csv", header = TRUE))[-1]
expr(read.csv("foo.csv", header = TRUE))
t
!!!t
(!!!t)
expr(!!!t)
expr(f(!!!t))
f(t)
t
bind_rows(t)
results <- bind_cols(bind_rows(t), models)
results
dfs <- list(
a = data.frame(x = 1, y = 2),
b = data.frame(x = 3, y = 4)
)
dfs
bind_rows(dfs)
?mean
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = !!cond index = "state_factor", model = effect)
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = !!cond, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = !!cond, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
library(tidyverse)
library(plm)
library(rlang)
library(broom)
data_path <- "C:/Users/dougj/Documents/Data/Education"
states <- read_csv(file.path(data_path, "ASER trends over time", "aser_trends.csv"))
dists <- read_csv(file.path(data_path, "ASER District Data", "Clean", "aser_district_5_or_6.csv"))
# Create vector of all learning outcome variables
outcomes <- str_subset(names(states), "^std.*all$")
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
for (y in outcomes) {
print(y)
# create string of formula.
rx <- paste(y, "~ state_factor + year_factor + pvt")
print("Without MP")
fit_no_mp <- plm(rx, data = states, subset = (State != "madhyapradesh"), index = "state_factor")
fit_no_mp_tidy <- tidy(fit_no_mp)
print(fit_no_mp_tidy[fit_no_mp_tidy$term == "pvt",])
print("With MP")
fit_with_mp <- plm(rx, data = states, index = "state_factor")
fit_tidy <- tidy(fit_no_mp)
print(fit_no_mp_tidy[fit_no_mp_tidy$term == "pvt",])
}
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = !!cond, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
states
View(states)
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = !!cond, index = state_factor, model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = !!cond, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
log_vec <- eval(parse(text = condition))
plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
}
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   cond <- parse_expr(condition)
#   plm(rx, data, subset = !!cond, index = "state_factor", model = effect)
# }
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
results <- bind_cols(bind_rows(t), models)
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = !!cond, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
plm(rx, data, subset = expr(!!cond), index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
exec("plm", rx, data, subset = !!cond, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
exec("plm", rx, data, subset := !!cond, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
cond <- parse_expr(condition)
exec("plm", rx, data, index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
library(tidyverse)
library(plm)
library(rlang)
library(broom)
data_path <- "C:/Users/dougj/Documents/Data/Education"
states <- read_csv(file.path(data_path, "ASER trends over time", "aser_trends.csv"))
dists <- read_csv(file.path(data_path, "ASER District Data", "Clean", "aser_district_5_or_6.csv"))
# Create factor variable for states
states <- states %>%
mutate(state_factor = as.factor(State), year_factor = as.factor(year))
# Create data frame of model inputs
outcomes <- str_subset(names(states), "^std.*all$")
sub_data <- c("!is.na(states$State)", 'states$State != "madhyapradesh"')
model_types <- c("within", "fd")
models <- expand.grid(y = outcomes, condition = sub_data, effect = model_types) %>%
mutate_all(as.character)
# Create a function which takes as input the outcome variable, the subset condition, and the approach and fits fixed effect / first difference model
# fit_plm <- function(y, condition, effect) {
#   # Create the formula to use in all models
#   rx <- paste(y, "~ state_factor + year_factor + pvt")
#   log_vec <- eval(parse(text = condition))
#   plm(rx, data = states[log_vec,], index = "state_factor", model = effect)
# }
fit_plm <- function(y, condition, effect) {
# Create the formula to use in all models
rx <- paste(y, "~ state_factor + year_factor + pvt")
log_vec <- eval(parse(text = condition))
plm(rx, data, subset = parse_expr(condition), index = "state_factor", model = effect)
}
# t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
t <- pmap(models, fit_plm) %>% map(tidy) %>%  map(~ .x[.x$term =="pvt",])
